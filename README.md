# Основы JS

## Типы данных

В JS 8 типов данных:

- ```number```. У целочисленных диапазон +-(2^53 - 1)
- ```bigint``` - длина произвольная
- ```string```
- ```boolean```
- ```null``` - _неизвестные_ значения
- ```undefined``` - _неприсвоенные_ значения
- ```object```
- ```symbol```

---

```typeof x``` или ```typeof(x)```

Также есть специальные числовые значения:

- ```Infinity``` (можно получить поделив на 0)
- ```-Infinity```
- ```NaN``` (при любых вычислительных ошибках)

```NaN``` липучий. Любая математическая операция с ним возвращает ```NaN```

> ```
> console.log(typeof(null)); // "object"
> console.log(NaN**0) // 1
> ```
> Такие вот приколюхи в JS

## Переменные

```var```, ```let```, ```const``` - а что ж ещё можно тут сказать?)

## Преобразование типов

В JS три типа преобразований:

- В строку (String)
- В логическое значение (Boolean)
- В число (Number)

### Примитивные типы данных

#### Преобразование к типу String

```
String(123) // явное преобразование
123 + ''    // неявное преобразование
```

Однако:

```
String(Symbol('my symbol'))   // 'Symbol(my symbol)'
'' + Symbol('my symbol')      // ошибка TypeError
```

#### Преобразование к типу Boolean

```
Boolean(2)          // явное преобразование
if (2) { ... }      // неявное преобразование в логическом контексте
!!2                 // неявное преобразование логическим оператором
2 || 'hello'        // неявное преобразование логическим оператором
```

```0```, ```null```, ```underfined```, ```NaN```, ```""``` => ```false```
любое другое => ```true```

#### Преобразование к типу Number

```
Number('123')   // явное преобразование
+'123'          // неявное преобразование
123 != '456'    // неявное преобразование
4 > '5'         // неявное преобразование
5/null          // неявное преобразование
true | 0        // неявное преобразование
```

Примерно так это происходит:

```
Number(null)                   // 0
Number(undefined)              // NaN
Number(true)                   // 1
Number(false)                  // 0
Number(" 12 ")                 // 12
Number("-12.34")               // -12.34
Number("\n")                   // 0
Number(" 12s ")                // NaN
Number(123)                    // 123
```

##### Есть два правила:

1. При применении оператора ```==``` к ```null``` или ```undefined``` преобразования в число не производится. Значение ```null``` равно только ```null``` или ```undefined``` и не равно ничему больше.

```
null == 0               // false, null не преобразуется в 0
null == null            // true
undefined == undefined  // true
null == undefined       // true
```

2. Значение ```NaN``` _не равно ничему_, включая себя.

### Преобразование типов для объектов

Пускай это просто будет здесь. Запомню.

```
true + false             // 1
12 / "6"                 // 2
"number" + 15 + 3        // 'number153'
15 + 3 + "number"        // '18number'
[1] > null               // true
"foo" + + "bar"          // 'fooNaN'
'true' == true           // false
false == 'false'         // false
null == ''               // false
!!"false" == !!"true"    // true
['x'] == 'x'             // true 
[] + null + 1            // 'null1'
0 || "0" && {}           // {}
[1,2,3] == [1,2,3]       // false
{}+[]+{}+[1]             // '0[object Object]1'
!+[]+[]+![]              // 'truefalse'
new Date(0) - 0          // 0
new Date(0) + 0          // 'Thu Jan 01 1970 02:00:00(EET)0'
```

## Базовые операторы, математика

Операнд - то, к чему применяется оператор. Иногда называют аргументом.

Унарный оператор - тот, который применяется к одному операнду.

Бинарный оператор - тот, который применяется к двум операндам.

Инкремент и декремент.

++counter - 1
counter++ - 0

### Побитоовые операторы

- AND (и) (&)
- OR (|)
- XOR (^)
- NOT (~)
- LEFT SHIFT (<<)
- RIGHT SHIFT (>>)
- ZERO-FILL RIGHT SHIFT (>>>)

### Оператор "Запятая"

Каждое _выполняется_, но возвращается результат _последнего_.

## Операторы сравнения

тут всё просто (вроде)

## Циклы

- ```while```
- ```do...while```
- ```for```

Прерывание цикла: ```break```
Следующая итерация: ```continue``` (кста позволяет избежать вложенности)

Но ```break``` и ```continue``` нельзя использовать справа от оператора ```?```

_Метка_ имеет вид идентификатора с двоеточием перед циклом.

``` break <labelName> ```

Метки не позволяют "прыгнуть" куда угодно.

## if, if else, switch

Всё интуитивно понятно, вот только если ```break``` нет, то выполнение ```switch``` пойдет ниже по следующим ```case```, при этом остальные проверки игнорируются.